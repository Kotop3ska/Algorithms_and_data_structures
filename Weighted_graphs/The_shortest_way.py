"""
Дан ориентированный полный граф, рёбрам которого приписаны некоторые веса (длины). 
Веса могут быть и положительные, и отрицательные, и нулевые. 
Нас интересует минимум длин всех возможных путей между всеми парами различных вершин этого графа. 
Нужно будет выяснить, существует ли этот минимум, и, если существует, вычислить его. 
(Минимума не существует в том случае, если в графе можно найти путь отрицательной длины, сколь угодно большой по модулю).

Входные данные
В первой строке задано число вершин N≤50. 
Далее идёт матрица смежности графа, то есть N строк, в каждой из которых записано N чисел. 
j-ое число в i-ой строке матрицы смежности задает длину ребра, ведущего из i-й вершину в j-ую. 
Длины могут принимать любые значения от -1000000 до 1000000. Гарантируется, что на главной диагонали матрицы стоят нули.

Выходные данные
Выведите одно число – искомый минимум. Если его не существует, выведите  -1.
"""

def floyd_warshall(graph, n):
    dist = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            dist[i][j] = graph[i][j]

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] < float('inf') and dist[k][j] < float('inf'):  # Проверяем достижимость
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    for i in range(n):
        if dist[i][i] < 0:
            return -1

    min_val = float('inf')
    for i in range(n):
        for j in range(n):
            if i != j and dist[i][j] < min_val:
                min_val = dist[i][j]

    return min_val


n = int(input())
graph = [[int(i) for i in input().split()] for _ in range(n)]

print(floyd_warshall(graph, n))